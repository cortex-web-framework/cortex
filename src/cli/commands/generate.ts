/**
 * Generate command implementation
 * Zero dependencies, strictest TypeScript configuration
 */

import { existsSync, writeFileSync } from 'fs';
import { join } from 'path';
import type { CLICommand } from '../types.js';
import { colors } from '../utils/colors.js';
import { fileUtils } from '../utils/fs.js';

/**
 * Actor template
 */
function generateActorTemplate(name: string): string {
  const className = name.charAt(0).toUpperCase() + name.slice(1);
  return `/**
 * ${className} Actor
 * Generated by Cortex CLI
 */

import { Actor } from 'cortex';

export interface ${className}Message {
  type: string;
  payload?: unknown;
}

export interface ${className}State {
  // Add your state properties here
}

export class ${className}Actor implements Actor<${className}Message, ${className}State> {
  private state: ${className}State = {
    // Initialize state
  };

  async receive(message: ${className}Message): Promise<${className}State | void> {
    switch (message.type) {
      case 'INITIALIZE':
        return this.handleInitialize(message);
      default:
        console.warn(\`Unknown message type: \${message.type}\`);
    }
  }

  private async handleInitialize(message: ${className}Message): Promise<${className}State> {
    // Handle initialization
    return this.state;
  }

  getState(): ${className}State {
    return { ...this.state };
  }
}
`;
}

/**
 * Service template
 */
function generateServiceTemplate(name: string): string {
  const className = name.charAt(0).toUpperCase() + name.slice(1);
  return `/**
 * ${className} Service
 * Generated by Cortex CLI
 */

export interface ${className}Config {
  // Add your configuration properties here
}

export class ${className}Service {
  private config: ${className}Config;

  constructor(config: ${className}Config) {
    this.config = config;
  }

  async initialize(): Promise<void> {
    // Initialize service
  }

  async shutdown(): Promise<void> {
    // Clean up resources
  }

  // Add your service methods here
}
`;
}

/**
 * Route template
 */
function generateRouteTemplate(name: string): string {
  return `/**
 * ${name} Routes
 * Generated by Cortex CLI
 */

import { CortexHttpServer } from 'cortex';

export function register${name.charAt(0).toUpperCase() + name.slice(1)}Routes(server: CortexHttpServer): void {
  // GET route
  server.get('/${name}', async (_req, res) => {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify({ message: 'Hello from ${name}' }));
  });

  // POST route
  server.post('/${name}', async (req, res) => {
    // Handle POST request
    res.statusCode = 201;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify({ message: '${name} created' }));
  });

  // PUT route
  server.put('/${name}/:id', async (req, res) => {
    // Handle PUT request
    res.statusCode = 200;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify({ message: '${name} updated' }));
  });

  // DELETE route
  server.delete('/${name}/:id', async (req, res) => {
    // Handle DELETE request
    res.statusCode = 204;
    res.end();
  });
}
`;
}

/**
 * Test template
 */
function generateTestTemplate(name: string, type: 'actor' | 'service' | 'route'): string {
  const className = name.charAt(0).toUpperCase() + name.slice(1);

  if (type === 'actor') {
    return `/**
 * ${className} Actor Tests
 * Generated by Cortex CLI
 */

import { describe, it, expect } from 'vitest';
import { ${className}Actor } from './${name}.js';

describe('${className}Actor', () => {
  it('should initialize correctly', async () => {
    const actor = new ${className}Actor();
    const state = actor.getState();
    expect(state).toBeDefined();
  });

  it('should handle INITIALIZE message', async () => {
    const actor = new ${className}Actor();
    const result = await actor.receive({ type: 'INITIALIZE' });
    expect(result).toBeDefined();
  });
});
`;
  }

  if (type === 'service') {
    return `/**
 * ${className} Service Tests
 * Generated by Cortex CLI
 */

import { describe, it, expect } from 'vitest';
import { ${className}Service } from './${name}.js';

describe('${className}Service', () => {
  it('should initialize correctly', async () => {
    const service = new ${className}Service({});
    await service.initialize();
    expect(service).toBeDefined();
  });

  it('should shutdown cleanly', async () => {
    const service = new ${className}Service({});
    await service.initialize();
    await service.shutdown();
    expect(service).toBeDefined();
  });
});
`;
  }

  return `/**
 * ${name} Routes Tests
 * Generated by Cortex CLI
 */

import { describe, it, expect } from 'vitest';
import { CortexHttpServer } from 'cortex';
import { register${className}Routes } from './${name}.js';

describe('${className} Routes', () => {
  it('should register routes', () => {
    const server = new CortexHttpServer();
    register${className}Routes(server);
    expect(server).toBeDefined();
  });
});
`;
}

/**
 * Generate actor command
 */
const generateActorCommand: CLICommand = {
  name: 'actor',
  description: 'Generate a new actor',
  action: async (args: string[], options: Record<string, unknown>): Promise<void> => {
    const name = args[0];
    if (!name) {
      console.log(colors.error('❌ Actor name is required'));
      console.log(`Usage: ${colors.cyan('cortex generate actor <name>')}`);
      process.exit(1);
      return;
    }

    const withTests = options['with-tests'] as boolean ?? true;
    const actorsDir = join(process.cwd(), 'src', 'actors');

    // Ensure actors directory exists
    fileUtils.ensureDir(actorsDir);

    const actorPath = join(actorsDir, `${name}.ts`);
    if (existsSync(actorPath)) {
      console.log(colors.warning(`⚠️  Actor ${name} already exists`));
      process.exit(1);
      return;
    }

    // Generate actor file
    const actorContent = generateActorTemplate(name);
    writeFileSync(actorPath, actorContent);
    console.log(colors.success(`✅ Created actor: ${actorPath}`));

    // Generate test file
    if (withTests) {
      const testsDir = join(process.cwd(), 'tests', 'actors');
      fileUtils.ensureDir(testsDir);
      const testPath = join(testsDir, `${name}.test.ts`);
      const testContent = generateTestTemplate(name, 'actor');
      writeFileSync(testPath, testContent);
      console.log(colors.success(`✅ Created test: ${testPath}`));
    }

    console.log(colors.info(`\nNext steps:`));
    console.log(`  1. Implement actor logic in ${colors.cyan(`src/actors/${name}.ts`)}`);
    console.log(`  2. Register actor in your actor system`);
    if (withTests) {
      console.log(`  3. Run tests: ${colors.cyan('cortex test')}`);
    }
  },
};

/**
 * Generate service command
 */
const generateServiceCommand: CLICommand = {
  name: 'service',
  description: 'Generate a new service',
  action: async (args: string[], options: Record<string, unknown>): Promise<void> => {
    const name = args[0];
    if (!name) {
      console.log(colors.error('❌ Service name is required'));
      console.log(`Usage: ${colors.cyan('cortex generate service <name>')}`);
      process.exit(1);
      return;
    }

    const withTests = options['with-tests'] as boolean ?? true;
    const servicesDir = join(process.cwd(), 'src', 'services');

    // Ensure services directory exists
    fileUtils.ensureDir(servicesDir);

    const servicePath = join(servicesDir, `${name}.ts`);
    if (existsSync(servicePath)) {
      console.log(colors.warning(`⚠️  Service ${name} already exists`));
      process.exit(1);
      return;
    }

    // Generate service file
    const serviceContent = generateServiceTemplate(name);
    writeFileSync(servicePath, serviceContent);
    console.log(colors.success(`✅ Created service: ${servicePath}`));

    // Generate test file
    if (withTests) {
      const testsDir = join(process.cwd(), 'tests', 'services');
      fileUtils.ensureDir(testsDir);
      const testPath = join(testsDir, `${name}.test.ts`);
      const testContent = generateTestTemplate(name, 'service');
      writeFileSync(testPath, testContent);
      console.log(colors.success(`✅ Created test: ${testPath}`));
    }

    console.log(colors.info(`\nNext steps:`));
    console.log(`  1. Implement service logic in ${colors.cyan(`src/services/${name}.ts`)}`);
    console.log(`  2. Initialize service in your application`);
    if (withTests) {
      console.log(`  3. Run tests: ${colors.cyan('cortex test')}`);
    }
  },
};

/**
 * Generate route command
 */
const generateRouteCommand: CLICommand = {
  name: 'route',
  description: 'Generate API routes',
  action: async (args: string[], options: Record<string, unknown>): Promise<void> => {
    const name = args[0];
    if (!name) {
      console.log(colors.error('❌ Route name is required'));
      console.log(`Usage: ${colors.cyan('cortex generate route <name>')}`);
      process.exit(1);
      return;
    }

    const withTests = options['with-tests'] as boolean ?? true;
    const routesDir = join(process.cwd(), 'src', 'routes');

    // Ensure routes directory exists
    fileUtils.ensureDir(routesDir);

    const routePath = join(routesDir, `${name}.ts`);
    if (existsSync(routePath)) {
      console.log(colors.warning(`⚠️  Route ${name} already exists`));
      process.exit(1);
      return;
    }

    // Generate route file
    const routeContent = generateRouteTemplate(name);
    writeFileSync(routePath, routeContent);
    console.log(colors.success(`✅ Created route: ${routePath}`));

    // Generate test file
    if (withTests) {
      const testsDir = join(process.cwd(), 'tests', 'routes');
      fileUtils.ensureDir(testsDir);
      const testPath = join(testsDir, `${name}.test.ts`);
      const testContent = generateTestTemplate(name, 'route');
      writeFileSync(testPath, testContent);
      console.log(colors.success(`✅ Created test: ${testPath}`));
    }

    console.log(colors.info(`\nNext steps:`));
    console.log(`  1. Implement route handlers in ${colors.cyan(`src/routes/${name}.ts`)}`);
    console.log(`  2. Register routes in your server setup`);
    if (withTests) {
      console.log(`  3. Run tests: ${colors.cyan('cortex test')}`);
    }
  },
};

/**
 * Main generate command
 */
export const generateCommand: CLICommand = {
  name: 'generate',
  description: 'Generate code scaffolding (actor, service, route)',
  options: [
    {
      name: 'with-tests',
      description: 'Generate test files',
      type: 'boolean',
      default: true,
    },
  ],
  subcommands: [generateActorCommand, generateServiceCommand, generateRouteCommand],
  action: async (args: string[]): Promise<void> => {
    if (args.length === 0) {
      console.log(colors.bold('cortex generate'));
      console.log('Generate code scaffolding\n');
      console.log(colors.bold('Available generators:\n'));
      console.log(`  ${colors.cyan('actor')}    Generate a new actor`);
      console.log(`  ${colors.cyan('service')}  Generate a new service`);
      console.log(`  ${colors.cyan('route')}    Generate API routes\n`);
      console.log(`Usage: ${colors.cyan('cortex generate <type> <name>')}`);
      console.log(`Example: ${colors.cyan('cortex generate actor MyActor')}`);
      return;
    }

    const type = args[0];
    const subArgs = args.slice(1);

    switch (type) {
      case 'actor':
        await generateActorCommand.action(subArgs, {});
        break;
      case 'service':
        await generateServiceCommand.action(subArgs, {});
        break;
      case 'route':
        await generateRouteCommand.action(subArgs, {});
        break;
      default:
        console.log(colors.error(`❌ Unknown generator: ${type}`));
        console.log(`Available generators: ${colors.cyan('actor')}, ${colors.cyan('service')}, ${colors.cyan('route')}`);
        process.exit(1);
    }
  },
};
